# [miniSAT求解器](https://zhuanlan.zhihu.com/p/103679514)

总览历代知名的基于DPLL算法的SAT求解器，回溯的依据无外乎以下三种：

1. 冲突分析（回溯到引起冲突的决策变量的最小决策深度）
2. 子句记录（将引起冲突的子句的矛盾变量记录下来，同时取非，做析取式，成为学习到的子句，因此该过程也称之为子句的学习）
3. 通过检测文字进行布尔约束传播（BCP）。

我们称以上风格的SAT solver为**矛盾驱动式**SAT求解器。

泛泛而谈，这些求解器总的来说有三个特点：

- *表现形式*：无论是怎样的算法，sat solver总需要一个精心设计的数据结构来解决。
- *推理论证*：暴力搜索从来不是解决问题的最好的方法，一个良好的求解器需要具有一个成体系的机制来从当前形势推理计算和前/后向传播挖掘或学习到的知识（比如，冲突子句，回溯深度）。
- *搜索求解*：推理往往与搜索相辅相成，适当的遍历也可以从中挖掘出有用的信息（这一定程度上是依赖于搜索的策略，比如选择决策变元的策略）。

现在广为人知的推理方法是**单子句传播**（unit-propagation）。只要在当前赋值下有一个子句成为了单子句（也就是对子句t，有且仅有一个变元未经赋真值，其他变元在该子句情形下均已赋值为假，例如FALSE or FALSE or FALSE ……or UNASSIGNED or FALSE…… or FALSE）。在这种情形下，仅存的变元将会被赋予真值TRUE，相当于为公式F添加了新的子句x，也就是F and x。每次单子句传播后都会检查是否是否有新的子句因此而成立，时刻监视更新当前的状况。以此类推，不断重复单子句传播过程，直至不再有可供传播的单子句信息。

sat solver的搜索过程是一个更加复杂的过程，往往采用启发式的算法，为每一个未经赋值的变元计算其（我称之为）**pick level（挑选等级）**，计算的方式又有多种多样，但往往是依据该变元在不同子句出现的次数赋以加权取和作为分数，取等级最高者优先赋以真值进行单子句传播过程，直到遇到冲突。此时依据当前遇到的冲突会相应的构造一个冲突子句作为学习到的子句加入公式F（假设当前形势下的冲突是a,b,c,d引起的，a,b,c,d均为决策变元而非应用变元，那么我们将构造(-a or -b or -c or -d)作为学习到的冲突子句 ），然后sat solver将进行回溯**直到学习到的冲突子句成为一个（广义上的）单子句**（通过本地的操作栈，将从当前冲突造成的操作数对应的操作一个个出栈进行reverse F from F and x，直到学习到的冲突子句出现一个未赋值变元）**，然后继续进行搜索过程。**

下面我们来讨论一下miniSAT求解器。

**传播**：miniSAT的传播过程受ZCHAFF的启发。对于每一个文字t，都会保存有一系列约束。当文字t被赋予真值TRUE时，对t的每一个约束（子句）都有可能会相应的进行单子句传播过程。对于子句，当且仅当除了一个未赋值变元t以外均被赋予FALSE时才会进行传播。某一子句的两个自由变元p,q会因此被挑选出来，对这个子句的引用也会相应的加入到-p，和-q的子句列表。这样的文字被称为监视文字，约束式子的列表也因此称为监视列表。只要一个监视文字被赋以真值，相应的约束式（列表）会因此得到响应去检测是否有信息会得到传播，或者是挑选新的文字变元去监视。

这种监视系统的一个特点是在回溯过程中不需要对监视列表进行调整，回溯过程因此是个开销廉价的过程。

**学习**：miniSAT的学习过程与上述加入学习到的冲突子句的过程相同，不再赘述。学习过程主要服务于两个原因，其一是它会趋势求解器进行回溯，其二便是学习到的子句会作为新的信息加速求解过程。每一个子句只会占有常量的引用空间。随着学习到的子句越来越多，积累的影响会越来越庞大，因此，学习到的子句会定期的削减（shrink），仅保留对推理和学习过程时效性高的冲突子句，这又启发式过程进行判断。

**搜索**：过程同上定义，关于决策变元，应用变元，决策深度，算法深度，推荐cmu 的dpll tutorial进行品味。所有的赋值操作都会按顺序存储在栈中，这些操作我们不妨称之为 迹。迹由决策深度划分并且被用于在回溯过程。

决策阶段会一直持续到要么所有变量均被赋值时（此时我们称之为一个模型），要么产生了一个冲突。若遇到冲突，则学习过程将会得到响应，于是冲突子句将会加入到学习子句当中。迹将会被用于重置决策，一次重置一个决策深度的赋值操作，直到冲突子句中的一个决策变元成为未赋值状态方停止回溯。*根据设计的构造方法，冲突子句不被允许从冲突中直接生成一个带有两个及两个以上的未赋值文字。（**需要源码辅助理解**）*如果某个子句在多个决策深度中保持单子句形式，那么这种情形下选择最小决策深度进行回溯将是一个最优选择。

![img](https://pic3.zhimg.com/80/v2-4e63e1bebba33142d3ba8686d9f017b2_1440w.webp)

**启发式活跃度衡量**： 在挑选变元进行赋值决策时，我们会有一个活跃度的衡量标准，每次一个新的冲突子句被记录，冲突子句中的变元的活跃度就会加一，我们称之为**冲撞**bumping。在记录冲突以后，所有变元的活跃度都会乘以一个小于1的系数降低活跃度。最近的活跃度增量要大于先前的活跃度增量。miniSAT也对子句使用了相似的思想，当学习到的子句被应用到冲突的分析过程中时，子句的活跃度会发生冲撞。不活跃的子句会移出学习子句行列。

**约束迁移与搜索策略**：sat问题的约束集域分为两部分：**原问题约束**和**学习子句约束**。显然，学习子句的规模会影响单子句传播的计算性能。但是，学习到的子句会被用于接下来的决策树剪枝，但是相应的也会付出扩大搜索空间的代价。两者的权衡需要精心考虑，miniSAT从一个小的约束域出发，随着求解的过程，约束域逐渐扩大。不定期的，miniSAT会皱缩学习子句，从而重启搜索空间，提高搜索性能。

接下来将是具体应用的阐述。

我们从程序运行时读读算法细节。

这是sat算例.cnf文件，首行字符c表示该行是注释信息，首行字符p表示该行会有文件信息，比如如下文件，会有20个变量（无符号，也就是1-20），91个约束子句。然后，4表示变量4，-18则表示变量18的取“非”形式，以此类推，每行末尾0表示该行结束。

```text
c This Formula is generated by mcnf
c
c    horn? no 
c    forced? no 
c    mixed sat? no 
c    clause length = 3 
c
p cnf 20 91
4 -18 19 0
3 18 -5 0
-5 -8 -15 0
-20 7 -16 0
10 -13 -7 0
-12 -9 17 0
17 19 5 0
-16 9 15 0
```

首先是读取文件信息。

```text
solver* s = solver_new();
lbool   st;
FILE *  in;
```

我们进入solver_new看一下

```c
solver* solver_new(void)
{
	solver* s = (solver*)malloc(sizeof(solver));

	// initialize vectors
	vecp_new(&s->clauses);//存储求解器中的子句
	vecp_new(&s->learnts);//存储学习到的字句
	veci_new(&s->order);//按顺序存储变元，基于活跃度大顶堆
	veci_new(&s->trail_lim);
	veci_new(&s->tagged);
	veci_new(&s->stack);
	veci_new(&s->model);

	// initialize arrays
	s->wlists = 0;
	s->activity = 0;
	s->assigns = 0;
	s->orderpos = 0;
	s->reasons = 0;
	s->levels = 0;
	s->tags = 0;
	s->trail = 0;


	// initialize other vars
	s->size = 0;
	s->cap = 0;
	s->qhead = 0;
	s->qtail = 0;
	s->cla_inc = 1;
	s->cla_decay = 1;
	s->var_inc = 1;
	s->var_decay = 1;
	s->root_level = 0;
	s->simpdb_assigns = 0;
	s->simpdb_props = 0;
	s->random_seed = 91648253;
	s->progress_estimate = 0;
	s->binary = (clause*)malloc(sizeof(clause) + sizeof(lit) * 2);
	s->binary->size_learnt = (2 << 1);
	s->verbosity = 0;

	s->stats.starts = 0;
	s->stats.decisions = 0;
	s->stats.propagations = 0;
	s->stats.inspects = 0;
	s->stats.conflicts = 0;
	s->stats.clauses = 0;
	s->stats.clauses_literals = 0;
	s->stats.learnts = 0;
	s->stats.learnts_literals = 0;
	s->stats.max_literals = 0;
	s->stats.tot_literals = 0;

	return s;
}
```

其中veci*new是创建新的向量，vecp_*new是创建新的向量组，并自动初始化固定大小，其方式含有push（添加新的元素），shrink（将尺寸重新reshape到较小，相当于出栈操作），veci_*size,vecp_*size(对应于返回向量和向量组的元素个数)等。

```text
if (argc != 2)
		fprintf(stderr, "ERROR! Not enough command line arguments.\n"),
		exit(1);

if (fopen_s(&in, argv[1], "rb"))
	fprintf(stderr, "ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]),
	exit(1);
st = parse_DIMACS(in, s);
fclose(in);

if (st == l_False) {
	solver_delete(s);
	printf("Trivial problem\nUNSATISFIABLE\n");
	exit(20);
}
```

其中in是对应的文件指针，s是minisat求解器，进入parse_DIMACS中观察。

```text
static lbool parse_DIMACS(FILE * in, solver* s) {
	char* text = readFile(in);
	lbool ret = parse_DIMACS_main(text, s);
	free(text);
	return ret;
}
```

继续进入parse_*DIMACS*_main观察

```text
static lbool parse_DIMACS_main(char* in, solver* s) {
	veci lits;
	veci_new(&lits);

	for (;;) {
		skipWhitespace(&in);//跳过空白字符知道遇到第一个非空白字符
		if (*in == 0)
			break;//已经到达行尾
		else if (*in == 'c' || *in == 'p')//该行是注释行和信息行
			skipLine(&in);//跳过该行
		else {//该行为约束子句
			lit* begin;
			readClause(&in, s, &lits);//将该行子句赋值给lits
			begin = veci_begin(&lits);
			if (!solver_addclause(s, begin, begin + veci_size(&lits))) {
				veci_delete(&lits);
				return l_False;
			}
		}
	}
	veci_delete(&lits);
	return solver_simplify(s);
}
```

进入函数readClause

```text
static void readClause(char** in, solver* s, veci* lits) {
	int parsed_lit, var;
	veci_resize(lits, 0);
	for (;;) {
		parsed_lit = parseInt(in);
		if (parsed_lit == 0) break;
		var = abs(parsed_lit) - 1;
		veci_push(lits, (parsed_lit > 0 ? toLit(var) : lit_neg(toLit(var))));
	}
}
```

进入函数parseInt

```text
static inline int parseInt(char** in) {
	int     val = 0;
	int    _neg = 0;
	skipWhitespace(in);//跳至下一个文字
	if (**in == '-') _neg = 1, (*in)++;
	else if (**in == '+') (*in)++;
	if (**in < '0' || **in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", **in), exit(1);
	while (**in >= '0' && **in <= '9')
		val = val * 10 + (**in - '0'),
		(*in)++;
	return _neg ? -val : val;
}
```

不难看出parseInt返回值是待被读取的下一个文字。

再次进入readClause查看

```text
static void readClause(char** in, solver* s, veci* lits) {
	int parsed_lit, var;
	veci_resize(lits, 0);
	for (;;) {
		parsed_lit = parseInt(in);读取下一个文字
		if (parsed_lit == 0) break;如果当前文字时0，说明子句已经结束
		var = abs(parsed_lit) - 1;当前文字的变量值为abs（lit）-1，也就是从0开始标号
		veci_push(lits, (parsed_lit > 0 ? toLit(var) : lit_neg(toLit(var))));
	}
}
```

这里，toLit,lit_neg(toLit(var))很有料

```text
static inline lit toLit(int v) { return v + v; }
static inline lit lit_neg(lit l) { return l ^ 1; }
```

所以，minisat中正文字的索引为其变元var<<1也就是乘以2，而负文字的索引为var<<1+1，也就是说正文字的索引序号为偶数，末尾为0，负文字末尾则为1.

于是返回某一文字对应变元，以及判断当前文字是否 有符号就显然了

```text
static inline lit lit_var(lit l) { return l >> 1; }
static inline lit lit_sign(lit l) { return (1 & l); }
```

回到读文件本身，在读取该行子句赋值给lits后，将通过下面一个函数将子句添加进入求解器。不难看出，该行数首先将要输入的约束子句中的进行从小到大的插入排序过程。

```c++
Bool solver_addclause(solver* s, lit* begin, lit* end)
{
	lit *i, *j;
	int maxvar;
	lbool* values;
	lit last;

	if (begin == end) return FALSE;

	//printlits(begin,end); printf("\n");
	// insertion sort
	maxvar = lit_var(*begin);
	for (i = begin + 1; i < end; i++) {
		lit l = *i;
		maxvar = lit_var(l) > maxvar ? lit_var(l) : maxvar;
		for (j = i; j > begin && *(j - 1) > l; j--)
			*j = *(j - 1);
		*j = l;
	}
	solver_setnvars(s, maxvar + 1);

	//printlits(begin,end); printf("\n");
	values = s->assigns;

	// delete duplicates
	last = lit_Undef;
	for (i = j = begin; i < end; i++) {
		//printf("lit: "L_LIT", value = %d\n", L_lit(*i), (lit_sign(*i) ? -values[lit_var(*i)] : values[lit_var(*i)]));
		lbool sig = !lit_sign(*i); sig += sig - 1;
		if (*i == lit_neg(last) || sig == values[lit_var(*i)])
			return TRUE;   // 如果当前子句中同时含有p与-p或者是因为其他单子句的关系使p恒成立，则当前子句恒成立，无需加入求解器约束集
		else if (*i != last && values[lit_var(*i)] == l_Undef)
			last = *j++ = *i;//将重复文字删除
	}

	//printf("final: "); printlits(begin,j); printf("\n");

	if (j == begin)          // empty clause
		return FALSE;
	else if (j - begin == 1) // unit clause
		return enqueue(s, *begin, (clause*)0);

	// create new clause
	vecp_push(&s->clauses, clause_new(s, begin, j, 0));


	s->stats.clauses++;
	s->stats.clauses_literals += j - begin;

	return TRUE;
}
```

在排序完成后，会通过solver*setnvars更新求解中关于变元的信息，注意这里的max*var是指最大的变元，而不是编码后的文字，注意排序过程中比较的是lit_var,至于为什么传参时+1，是为了方便for循环能够取到maxvar

```text
void solver_setnvars(solver* s, int n)
{
	int var;

	if (s->cap < n) {

		while (s->cap < n) s->cap = s->cap * 2 + 1;

		s->wlists = (vecp*)realloc(s->wlists, sizeof(vecp)*s->cap * 2);
		s->activity = (double*)realloc(s->activity, sizeof(double)*s->cap);
		s->assigns = (lbool*)realloc(s->assigns, sizeof(lbool)*s->cap);
		s->orderpos = (int*)realloc(s->orderpos, sizeof(int)*s->cap);
		s->reasons = (clause**)realloc(s->reasons, sizeof(clause*)*s->cap);
		s->levels = (int*)realloc(s->levels, sizeof(int)*s->cap);
		s->tags = (lbool*)realloc(s->tags, sizeof(lbool)*s->cap);
		s->trail = (lit*)realloc(s->trail, sizeof(lit)*s->cap);
	}

	for (var = s->size; var < n; var++) {
		vecp_new(&s->wlists[2 * var]);//每一个文字都会有一组watchlist
		vecp_new(&s->wlists[2 * var + 1]);
		s->activity[var] = 0;
		s->assigns[var] = l_Undef;
		s->orderpos[var] = veci_size(&s->order);
		s->reasons[var] = (clause*)0;
		s->levels[var] = 0;
		s->tags[var] = l_Undef;

		/* does not hold because variables enqueued at top level will not be reinserted in the heap
		assert(veci_size(&s->order) == var);
		*/
		veci_push(&s->order, var);
		order_update(s, var);//按活跃度进行大顶堆排序
	}

	s->size = n > s->size ? n : s->size;//s->size存储的是第一个空位置
}
```

在剔除重复文字和恒成立子句后，对于单子句，会进入enquene方法

```text
static inline Bool enqueue(solver* s, lit l, clause* from)
{
	lbool* values = s->assigns;
	int    v = lit_var(l);
	lbool  val = values[v];
#ifdef VERBOSEDEBUG
	printf("%-*denqueue(%sx%d)\n", L_ind, L_lit(l));
#endif

	lbool sig = !lit_sign(l); sig += sig - 1;
	if (val != l_Undef) {
		return val == sig;//p为1，若此单子句为-p，则返回FALSE，反之返回TRUE，该子句不添加
	}
	else {
		// New fact -- store it.
#ifdef VERBOSEDEBUG
		printf("%-*dbind(%sx%d)\n", L_ind, L_lit(l));
#endif
		int*     levels = s->levels;
		clause** reasons = s->reasons;

		values[v] = sig;//当且仅当value【v】==sig，当前单子句才成立
		levels[v] = solver_dlevel(s);
		reasons[v] = from;//使当前变元v赋值的原因约束子句是from，若是初始化则为NULL
		s->trail[s->qtail++] = l;//为文字赋值，要相应的将此操作加入trail中，便于reverse

		order_assigned(s, v);//minisat中该函数为空语句
		return TRUE;
	}
}
```

在这之后，对于非单子句的约束子句，会相应的将其添加入求解器的约束子句中，并将其加入首元取非的watch list，我们进入clause_new函数：

```text
static clause* clause_new(solver* s, lit* begin, lit* end, int learnt)
{
	int size;
	clause* c;
	int i;

	assert(end - begin > 1);
	assert(learnt >= 0 && learnt < 2);
	size = end - begin;
	c = (clause*)malloc(sizeof(clause) + sizeof(lit) * size + learnt * sizeof(float));
	c->size_learnt = (size << 1) | learnt;
	assert(((unsigned int)c & 1) == 0);

	for (i = 0; i < size; i++)
		c->lits[i] = begin[i];

	if (learnt)
		*((float*)&c->lits[size]) = 0.0;

	assert(begin[0] >= 0);
	assert(begin[0] < s->size * 2);
	assert(begin[1] >= 0);
	assert(begin[1] < s->size * 2);

	assert(lit_neg(begin[0]) < s->size * 2);
	assert(lit_neg(begin[1]) < s->size * 2);

	//vecp_push(solver_read_wlist(s,lit_neg(begin[0])),(void*)c);
	//vecp_push(solver_read_wlist(s,lit_neg(begin[1])),(void*)c);

	vecp_push(solver_read_wlist(s, lit_neg(begin[0])), (void*)(size > 2 ? c : clause_from_lit(begin[1])));
	vecp_push(solver_read_wlist(s, lit_neg(begin[1])), (void*)(size > 2 ? c : clause_from_lit(begin[0])));

	return c;
}
//在最后我们可以看到，初始化时是为每个子句添加了两个watch literal，分别为子句的第一个元素和第二个元素
//为每个watch litral的取非文字提供watch list
//如果当前子句本身多于2个元素，则直接添加当前子句
//因为wlist是存储着子句的列表，每个元素其实是子句的地址，所以相应的，对于长度为2的子句，会把另外一个文字作为一个
//单子句传入对应的watch list，传入的单子句地址为
//clause* clause_from_lit(lit l) { return (clause*)((unsigned long)l + (unsigned long)l + 1); }
//watch list中的单子句的clause
显然末尾也是1 ，这里显然赋值给的是子句的大小
又前方子句定义c->size_learnt = (size << 1) | learnt;
可知，在leant为0时非2-子句的size_learn域应为0
因此这成为了判断否为单文字构建的watch list的标准
```

由上述可以见得，addclause当且仅当前子句不成立时才会返回FALSE，相应的调用函数也会返回FALSE，在数据结构的构造阶段，这表示由于本身冲突单子句的问题，该sat问题不可解。addclause本身也对公式F进行了一定程度的简化，包括，删除子句中的重复文字 ，拒绝添加因为某些单子句导致恒成立的非单子句，子句中的文字时依据相应的编码有序排列的，以及添加单子句对应的文字并使之成立，进入trail（enquene操作）便于后续通过单子句传播规则进行进一步的简化。

最后，进行简化公式。

```text
Bool   solver_simplify(solver* s)
{
	clause** reasons;
	int type;

	assert(solver_dlevel(s) == 0);

	if (solver_propagate(s) != 0)
		return FALSE;

	if (s->qhead == s->simpdb_assigns || s->simpdb_props > 0)//存疑
		return TRUE;

	reasons = s->reasons;
	for (type = 0; type < 2; type++) {
		vecp*    cs = type ? &s->learnts : &s->clauses;
		clause** cls = (clause**)vecp_begin(cs);

		int i, j;
		for (j = i = 0; i < vecp_size(cs); i++) {
			if (reasons[lit_var(*clause_begin(cls[i]))] != cls[i] &&
				clause_simplify(s, cls[i]) == l_True)
				clause_remove(s, cls[i]);
			else
				cls[j++] = cls[i];
		}
		vecp_resize(cs, j);
	}

	s->simpdb_assigns = s->qhead;
	// (shouldn't depend on 'stats' really, but it will do for now)
	s->simpdb_props = (int)(s->stats.clauses_literals + s->stats.learnts_literals);

	return TRUE;
}
```

简化公式的依据是利用单子句进行前向传播过程，若传播过程中出现冲突语句，则该公式为矛盾公式，返回FALSE,求解器将拒绝求解。注意到这里有简化子句的函数clause_simplify

```text
static lbool clause_simplify(solver* s, clause* c)
{
	lit*   lits = clause_begin(c);
	lbool* values = s->assigns;
	int i;

	assert(solver_dlevel(s) == 0);

	for (i = 0; i < clause_size(c); i++) {
		lbool sig = !lit_sign(lits[i]); sig += sig - 1;
		if (values[lit_var(lits[i])] == sig)
			return l_True;
	}
	return l_False;
}
```

可以看出，clause_simplify会判断输入子句是否已经满足。

回到简化公式F中，如果当前子句已经因为单子句传播规则横成立，并且该子句首元赋值的原因子句不是当前子句，则将该子句移出。至于为什么这样做，我们还需要根据前向传播过程来仔细考量。更新完成后返回TRUE。

下面来查看下前向传播的实现。

```text
static inline vecp*   solver_read_wlist(solver* s, lit l) { return &s->wlists[l]; }
//返回文字l的watch list
static inline lit*  clause_begin(clause* c) { return c->lits; }
//返回当前子句
clause* clause_from_lit(lit l) { return (clause*)((unsigned long)l + (unsigned long)l + 1); }
//watch list中的单子句的clause
bool    clause_is_lit(clause* c) { return ((unsigned long)c & 1); }
//判断该watch list中的当前子句是否为lit
lit     clause_read_lit(clause* c) { return (lit)((unsigned long)c >> 1); }
//但会该watch list单子句中的文字
clause* solver_propagate(solver* s)
{
	lbool*  values = s->assigns;
	clause* confl = (clause*)0;
	lit*    lits;

	//printf("solver_propagate\n");
	while (confl == 0 && s->qtail - s->qhead > 0) {
		lit  p = s->trail[s->qhead++];//从已经赋值的单子句列表trail中先进先出进行正向传播
		vecp* ws = solver_read_wlist(s, p);//确定p的watch lists
		clause **begin = (clause**)vecp_begin(ws);
		clause **end = begin + vecp_size(ws);//begin and end 为p的watch lists首尾
		clause **i, **j;

		s->stats.propagations++;
		s->simpdb_props--;

		//printf("checking lit %d: "L_LIT"\n", veci_size(ws), L_lit(p));
		for (i = j = begin; i < end; ) {
			if (clause_is_lit(*i)) {//如果对应ip的watchlist中某一子句为单子句
				*j++ = *i;//执行的是watch list 的copy操作
				if (!enqueue(s, clause_read_lit(*i), clause_from_lit(p))) {
                                        //该文字将被动赋值使该子句为真
                                        //若为成功则继续，若失败则记录冲突并退出前项传播过程
                                        //学习到的子句第二项应为传播文字的取非文字，（q，-p）
					confl = s->binary;
					(clause_begin(confl))[1] = lit_neg(p);
					(clause_begin(confl))[0] = clause_read_lit(*i++);

					// Copy the remaining watches:
					while (i < end)
						*j++ = *i++;
				}
			}
			else {
				lit false_lit;
				lbool sig;

				lits = clause_begin(*i);

				// Make sure the false literal is data[1]:
				false_lit = lit_neg(p);
				if (lits[0] == false_lit) {
					lits[0] = lits[1];
					lits[1] = false_lit;
				}
				assert(lits[1] == false_lit);
				//printf("checking clause: "); printlits(lits, lits+clause_size(*i)); printf("\n");

				// If 0th watch is true, then clause is already satisfied.
				sig = !lit_sign(lits[0]); sig += sig - 1;
				if (values[lit_var(lits[0])] == sig) {
					*j++ = *i;
				}
				else {
					// Look for new watch:
					lit* stop = lits + clause_size(*i);
					lit* k;
					for (k = lits + 2; k < stop; k++) {
						lbool sig = lit_sign(*k); sig += sig - 1;
						if (values[lit_var(*k)] != sig) {
                                         //因为单子句传播规则且当前子句前两元均不满足成立条件，
                    //所以我们替换第二个watch literal 为新的文字，满足要么尚未赋值要么已经成立的文字，
                    //当前watch literal不再保留该list
							lits[1] = *k;
							*k = false_lit;
							vecp_push(solver_read_wlist(s, lit_neg(lits[1])), *i);
							goto next;
						}
					}
                                        //没有找到新的watch literal 说明该子句在当前赋值下
                                        //只有第一个文字时未赋值的变元，即单子句
					*j++ = *i;
					// Clause is unit under assignment:
					if (!enqueue(s, lits[0], *i)) {
						confl = *i++;
						// Copy the remaining watches:
						while (i < end)
							*j++ = *i++;
					}
				}
			}
		next:
			i++;
		}

		s->stats.inspects += j - (clause**)vecp_begin(ws);//统计watch list中子句数量
		vecp_resize(ws, j - (clause**)vecp_begin(ws));//更新当前watch list大小
	}

	return confl;
}
```



至此进入主要求解函数，begin和end意义尚不明确

```text
int begin = 0;
int end = 0;
st = solver_solve(s, &begin, &end);
```

求解函数如下：

```text
Bool  solver_solve(solver* s, lit* begin, lit* end)
{
	double  nof_conflicts = 100;//初始化冲突数量
	double  nof_learnts = solver_nclauses(s) / 3;//初始化学习子句数量(为总子句数量的1/3)
	lbool   status = l_Undef;//初始化求解器状态为未定义
	lbool*  values = s->assigns;
	lit*    i;

	//printf("solve: "); printlits(begin, end); printf("\n");
	for (i = begin; i < end; i++) {
		switch (lit_sign(*i) ? -values[lit_var(*i)] : values[lit_var(*i)]) {
		case 1: /* l_True: */
			break;
		case 0: /* l_Undef */
			assume(s, *i);
			if (solver_propagate(s) == NULL)
				break;
			// falltrough
		case -1: /* l_False */
			solver_canceluntil(s, 0);
			return false;
		}
	}

	s->root_level = solver_dlevel(s);//求解算法深度（通过trail）

	if (s->verbosity >= 1) {//判断输出的打印形式
		printf("==================================[MINISAT]===================================\n");
		printf("| Conflicts |     ORIGINAL     |              LEARNT              | Progress |\n");
		printf("|           | Clauses Literals |   Limit Clauses Literals  Lit/Cl |          |\n");
		printf("==============================================================================\n");
	}

	while (status == l_Undef) {//当求解器尚未求解完成时持续进行求解
		double Ratio = (s->stats.learnts == 0) ? 0.0 :
			s->stats.learnts_literals / (double)s->stats.learnts;

		if (s->verbosity >= 1) {
			printf("| %9.0f | %7.0f %8.0f | %7.0f %7.0f %8.0f %7.1f | %6.3f %% |\n",
				(double)s->stats.conflicts,
				(double)s->stats.clauses,
				(double)s->stats.clauses_literals,
				(double)nof_learnts,
				(double)s->stats.learnts,
				(double)s->stats.learnts_literals,
				Ratio,
				s->progress_estimate * 100);
			fflush(stdout);
		}
		status = solver_search(s, (int)nof_conflicts, (int)nof_learnts);
		nof_conflicts *= 1.5;
		nof_learnts *= 1.1;
	}
	if (s->verbosity >= 1)
		printf("==============================================================================\n");

	solver_canceluntil(s, 0);
	return status != l_False;
}
```

但不难看出主要部分还是就一个函数solver_search,在尚未求解完成时就不断增加允许的最大冲突子句和学习子句数

```text
static lbool solver_search(solver* s, int nof_conflicts, int nof_learnts)
{
	int*    levels = s->levels;//算法深度
	double  var_decay = 0.95;
	double  clause_decay = 0.999;
	double  random_var_freq = 0.02;

	int     conflictC = 0;
	veci    learnt_clause;

	assert(s->root_level == solver_dlevel(s));

	s->stats.starts++;
	s->var_decay = (float)(1 / var_decay);
	s->cla_decay = (float)(1 / clause_decay);
	veci_resize(&s->model, 0);
	veci_new(&learnt_clause);

	for (;;) {
		clause* confl = solver_propagate(s);
		if (confl != 0) {
			// CONFLICT
			int blevel;
			s->stats.conflicts++; conflictC++;
			if (solver_dlevel(s) == s->root_level) {
				veci_delete(&learnt_clause);
				return l_False;
			}

			veci_resize(&learnt_clause, 0);
			solver_analyze(s, confl, &learnt_clause);
			blevel = veci_size(&learnt_clause) > 1 ? levels[lit_var(veci_begin(&learnt_clause)[1])] : s->root_level;
			blevel = s->root_level > blevel ? s->root_level : blevel;
			solver_canceluntil(s, blevel);
			solver_record(s, &learnt_clause);
			act_var_decay(s);
			act_clause_decay(s);

		}
		else {
			// NO CONFLICT
			int next;

			if (nof_conflicts >= 0 && conflictC >= nof_conflicts) {
				// Reached bound on number of conflicts:
				s->progress_estimate = solver_progress(s);
				solver_canceluntil(s, s->root_level);
				veci_delete(&learnt_clause);
				return l_Undef;
			}

			if (solver_dlevel(s) == 0)
				// Simplify the set of problem clauses:
				solver_simplify(s);

			if (nof_learnts >= 0 && vecp_size(&s->learnts) - s->qtail >= nof_learnts)
				// Reduce the set of learnt clauses:
				solver_reducedb(s);

			// New variable decision:
			s->stats.decisions++;
			next = order_select(s, (float)random_var_freq);

			if (next == var_Undef) {
				// Model found:
				lbool* values = s->assigns;
				int i;
				for (i = 0; i < s->size; i++) veci_push(&s->model, (int)values[i]);
				solver_canceluntil(s, s->root_level);
				veci_delete(&learnt_clause);

				return l_True;
			}

			assume(s, lit_neg(toLit(next)));
		}
	}

	return l_Undef; // cannot happen
}
```

首先是对冲突分析函数solver_analyze

```text
//注意到初始化时s->binary->size_learnt = (2 << 1);
static void solver_analyze(solver* s, clause* c, veci* learnt)
{
	lit*     trail = s->trail;
	lbool*   tags = s->tags;
	clause** reasons = s->reasons;
	int*     levels = s->levels;
	int      cnt = 0;
	lit      p = lit_Undef;
	int      ind = s->qtail - 1;
	lit*     lits;
	int      i, j, minl;
	int*     tagged;

	veci_push(learnt, lit_Undef);

	do {
		assert(c != 0);

		if (clause_is_lit(c)) {
			lit q = clause_read_lit(c);
			
			if (tags[lit_var(q)] == l_Undef && levels[lit_var(q)] > 0) {
				tags[lit_var(q)] = l_True;
				veci_push(&s->tagged, lit_var(q));
				act_var_bump(s, lit_var(q));
				if (levels[lit_var(q)] == solver_dlevel(s))
					cnt++;
				else
					veci_push(learnt, q);
			}
		}
		else {

			if (clause_learnt(c))
				act_clause_bump(s, c);

			lits = clause_begin(c);
			//printlits(lits,lits+clause_size(c)); printf("\n");
			for (j = (p == lit_Undef ? 0 : 1); j < clause_size(c); j++) {
				lit q = lits[j];
				assert(lit_var(q) >= 0 && lit_var(q) < s->size);
				if (tags[lit_var(q)] == l_Undef && levels[lit_var(q)] > 0) {
					tags[lit_var(q)] = l_True;
					veci_push(&s->tagged, lit_var(q));
					act_var_bump(s, lit_var(q));
					if (levels[lit_var(q)] == solver_dlevel(s))
						cnt++;
					else
						veci_push(learnt, q);
				}
			}
		}

		while (tags[lit_var(trail[ind--])] == l_Undef);

		p = trail[ind + 1];
		c = reasons[lit_var(p)];
		cnt--;

	} while (cnt > 0);

	*veci_begin(learnt) = lit_neg(p);

	lits = veci_begin(learnt);
	minl = 0;
	for (i = 1; i < veci_size(learnt); i++) {
		int lev = levels[lit_var(lits[i])];
		minl |= 1 << (lev & 31);
	}

	// simplify (full)
	for (i = j = 1; i < veci_size(learnt); i++) {
		if (reasons[lit_var(lits[i])] == 0 || !solver_lit_removable(s, lits[i], minl))
			lits[j++] = lits[i];
	}

	// update size of learnt + statistics
	s->stats.max_literals += veci_size(learnt);
	veci_resize(learnt, j);
	s->stats.tot_literals += j;

	// clear tags
	tagged = veci_begin(&s->tagged);
	for (i = 0; i < veci_size(&s->tagged); i++)
		tags[tagged[i]] = l_Undef;
	veci_resize(&s->tagged, 0);

	if (veci_size(learnt) > 1) {
		int max_i = 1;
		int max = levels[lit_var(lits[1])];
		lit tmp;

		for (i = 2; i < veci_size(learnt); i++)
			if (levels[lit_var(lits[i])] > max) {
				max = levels[lit_var(lits[i])];
				max_i = i;
			}

		tmp = lits[1];
		lits[1] = lits[max_i];
		lits[max_i] = tmp;
	}

}
```